"use strict";(self.webpackChunkgo_beyond=self.webpackChunkgo_beyond||[]).push([[385],{8295:(a,s)=>{s.A=(a,s)=>{const e=a.__vccOpts||a;for(const[a,t]of s)e[a]=t;return e}},4410:(a,s,e)=>{e.r(s),e.d(s,{comp:()=>r,data:()=>o});var t=e(4691);const l={},r=(0,e(8295).A)(l,[["render",function(a,s){return(0,t.uX)(),(0,t.CE)("div",null,s[0]||(s[0]=[(0,t.Fv)('<p>ClassLoader</p><p>定义：顾名思义，它是用来加载 Class 的。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。</p><p>**延迟加载：**JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。</p><p><strong>各司其职：</strong></p><p><strong>BootstrapClassLoader</strong> 负责加载 JVM 运行时核心类，这些类位于 $JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.xxx.* 都在里面，比如 java.util.、java.io.、java.nio.、java.lang. 等等。这个 ClassLoader 比较特殊，它是由 C 代码实现的，我们将它称之为「根加载器」。</p><p><strong>ExtensionClassLoader</strong> 负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 $JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。</p><p><strong>AppClassLoader</strong> 才是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。</p><p>ClassLoader的传递性：</p><p>当程序运行时遇到一个需要加载的类时，会选择使用调用者Class对象的ClassLoader来加载当前未知的类。因为ClassLoader的传递性，所有延迟加载的类都会由初始调用main方法的的这个ClassLoader全权负责，也就是AppClassLoader</p><h2 id="双亲委派" tabindex="-1"><a class="header-anchor" href="#双亲委派"><span>双亲委派</span></a></h2><ul><li><p>系统类防止内存中出现多份同样的字节码</p></li><li><p>保证Java程序安全稳定运行，类加载器是Java安全模型的一部分，用于加载和执行代码。如果类加载器的使用不当，可能会导致安全漏洞，如类注入攻击</p><p>如果用不同的classloader加载同一个字节码会导致问题</p><ol><li>ClassCastException 因为不是一个Class，所以类型转换出问题</li><li>垃圾回收时如果当一个Class对象触发了垃圾回收，把字节码也回收了，那其他的class对象也会报错。</li><li>如果class字节码或者资源访问是基于类加载器的，那么会产生资源访问冲突。</li></ol></li></ul><p>自定义类加载器是为了解决当.class文件不在classpath路径中时，寻找加载.class而存在的</p>',12)]))}]]),o=JSON.parse('{"path":"/architecture-design/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.html","title":"","lang":"zh-CN","frontmatter":{"description":"ClassLoader 定义：顾名思义，它是用来加载 Class 的。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。 **延迟加载：**JVM...","head":[["meta",{"property":"og:url","content":"https://sciencefl.github.io/architecture-design/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.html"}],["meta",{"property":"og:site_name","content":"FlynnDocs 学习笔记"}],["meta",{"property":"og:description","content":"ClassLoader 定义：顾名思义，它是用来加载 Class 的。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。 **延迟加载：**JVM..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-01T07:47:50.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-01T07:47:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-01T07:47:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flynn\\",\\"url\\":\\"https://sciencefl.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"双亲委派","slug":"双亲委派","link":"#双亲委派","children":[]}],"git":{"createdTime":1743493670000,"updatedTime":1743493670000,"contributors":[{"name":"fuliang","email":"fuliang@ssc-hn.com","commits":1}]},"readingTime":{"minutes":2.32,"words":696},"filePathRelative":"architecture-design/双亲委派.md","localizedDate":"2025年4月1日","excerpt":"<p>ClassLoader</p>\\n<p>定义：顾名思义，它是用来加载 Class 的。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。</p>\\n<p>**延迟加载：**JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。</p>","autoDesc":true}')}}]);